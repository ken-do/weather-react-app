/* eslint-disable import/no-extraneous-dependencies */
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import App from 'src/App'
import { Provider } from 'react-redux'
import store from 'src/server/store'
import fs from 'fs'
import { StaticRouter as Router } from 'react-router-dom'
import { StaticRouterContext } from 'react-router'
import { getLocations } from 'src/features/location/locationsSlice'
import { getDetails } from 'src/features/weather/detailsSlice'
import { Request } from 'express'
import { ChunkExtractor } from '@loadable/server'
import appRoot from 'app-root-path'
import { ParsedQs } from 'qs'

interface Action {
    creator: (
        payload: string
    ) => {
        payload: string
        type: string
    }
    getPayload: (
        request: Request
    ) => string | ParsedQs | string[] | ParsedQs[] | undefined
    done: () => boolean
}

// This is the stats file generated by webpack loadable plugin
const buildStatsFile = `${appRoot}/build/loadable-stats.json`
// This is a default stats file to fallback to, it's outdated and should be used for testing purpose only
const defaultStatsFile = `${appRoot}/public/loadable-stats.json`
// We create an extractor from the buildStatsFile
const extractor = fs.existsSync(buildStatsFile)
    ? new ChunkExtractor({ statsFile: buildStatsFile })
    : new ChunkExtractor({ statsFile: defaultStatsFile })

export const pagesWithActions = [
    {
        pattern: /^\/location/,
        actions: [
            {
                creator: (payload: string) => getLocations(payload),
                getPayload: (request: Request) => {
                    const { query } = request.query
                    return query
                },
                done: () => !store.getState().locations.isLoading,
            },
        ],
    },
    {
        pattern: /^\/weather\/([0-9]+)/,
        actions: [
            {
                creator: (payload: string) => getDetails(payload),
                // eslint-disable-next-line consistent-return
                getPayload: (request: Request) => {
                    const match = request.originalUrl.match(
                        /^\/weather\/([0-9]+)/
                    )
                    if (match) {
                        return match[1]
                    }
                },
                done: () => !store.getState().details.isLoading,
            },
        ],
    },
]

export const markActionsAsDone = (
    actions: Action[],
    done: (value: unknown) => void
) => {
    // wait for the API requests to finish
    // or resolve after having retried a few times
    const actionsDone = () => actions.every((action) => action.done())
    let retries = 6
    const intervalId = setInterval(() => {
        if (retries > 0 && !actionsDone()) {
            retries -= 1
        } else {
            clearInterval(intervalId)
            done(true)
        }
    }, 500)
}

export const triggerActions = async (request: Request) => {
    return new Promise((resolve) => {
        let hasMatchingPage = false
        pagesWithActions.forEach((page) => {
            if (page.pattern.test(request.originalUrl)) {
                hasMatchingPage = true
                page.actions.forEach((action) => {
                    const payload = action.getPayload(request)
                    store.dispatch(action.creator(payload as string))
                })
                markActionsAsDone(page.actions, resolve)
            }
        })
        if (!hasMatchingPage) {
            resolve(true)
        }
    })
}

export const renderAppToString = async (
    request: Request,
    routerContext: StaticRouterContext
) => {
    await triggerActions(request)
    const jsx = extractor.collectChunks(
        <Provider store={store}>
            <Router location={request.originalUrl} context={routerContext}>
                <App />
            </Router>
        </Provider>
    )
    const renderedApp = ReactDOMServer.renderToString(jsx)
    return renderedApp
}

export const injectPreloadedState = async (
    app: string,
    indexFilePath = `${appRoot}/build/index.html`
) => {
    try {
        const preloadedState = store.getState()
        const data = await fs.promises.readFile(indexFilePath, 'utf8')
        return data.replace(
            '<div id="root"></div>',
            `<div id="root">${app}</div> 
                <script>
                window.__PRELOADED_STATE__ = ${JSON.stringify(
                    preloadedState
                ).replace(/</g, '\\u003c')}
              </script>`
        )
    } catch (error) {
        return Promise.reject(
            new Error('Failed while trying to inject preloaded state')
        )
    }
}
