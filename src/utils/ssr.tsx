/* eslint-disable import/no-extraneous-dependencies */
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import App from 'src/App'
import { Provider } from 'react-redux'
import store from 'src/server/store'
import fs from 'fs'
import { StaticRouter as Router } from 'react-router-dom'
import { StaticRouterContext } from 'react-router'
import { getLocations } from 'src/features/location/locationsSlice'
import { getDetails } from 'src/features/weather/detailsSlice'
import { Request } from 'express'
import { ChunkExtractor } from '@loadable/server'
import appRoot from 'app-root-path'

// This is the stats file generated by webpack loadable plugin
const buildStatsFile = `${appRoot}/build/loadable-stats.json`
// This is a default stats file to fallback to, it's outdated and should be used for testing purpose only
const defaultStatsFile = `${appRoot}/public/loadable-stats.json`
// We create an extractor from the buildStatsFile
const extractor = fs.existsSync(buildStatsFile)
    ? new ChunkExtractor({ statsFile: buildStatsFile })
    : new ChunkExtractor({ statsFile: defaultStatsFile })

export const pagesWithActions = [
    {
        pattern: /^\/location/,
        actions: [
            {
                creator: (payload: string) => getLocations(payload),
                getPayload: (request: Request) => {
                    const { query } = request.query
                    return query
                },
            },
        ],
    },
    {
        pattern: /^\/weather\/([0-9]+)/,
        actions: [
            {
                creator: (payload: string) => getDetails(payload),
                // eslint-disable-next-line consistent-return
                getPayload: (request: Request) => {
                    const match = request.originalUrl.match(
                        /^\/weather\/([0-9]+)/
                    )
                    if (match) {
                        return match[1]
                    }
                },
            },
        ],
    },
]

export const triggerActions = (request: Request) => {
    pagesWithActions.forEach((page) => {
        if (page.pattern.test(request.originalUrl)) {
            page.actions.forEach((action) => {
                const payload = action.getPayload(request)
                store.dispatch(action.creator(payload as string))
            })
        }
    })
}

export const renderAppToString = async (
    request: Request,
    routerContext: StaticRouterContext
) => {
    triggerActions(request)
    // wait 1.5s for the API requests to finish
    // not an ideal solution but it works
    // needs to be improved later, maybe with a flag
    return new Promise<string>((resolve) => {
        setTimeout(() => {
            const jsx = extractor.collectChunks(
                <Provider store={store}>
                    <Router
                        location={request.originalUrl}
                        context={routerContext}
                    >
                        <App />
                    </Router>
                </Provider>
            )
            const renderedApp = ReactDOMServer.renderToString(jsx)
            resolve(renderedApp)
        }, 2000)
    })
}

export const injectPreloadedState = async (
    app: string,
    indexFilePath = `${appRoot}/build/index.html`
) => {
    try {
        const preloadedState = store.getState()
        const data = await fs.promises.readFile(indexFilePath, 'utf8')
        return data.replace(
            '<div id="root"></div>',
            `<div id="root">${app}</div> 
                <script>
                window.__PRELOADED_STATE__ = ${JSON.stringify(
                    preloadedState
                ).replace(/</g, '\\u003c')}
              </script>`
        )
    } catch (error) {
        return Promise.reject(
            new Error('Failed while trying to inject preloaded state')
        )
    }
}
